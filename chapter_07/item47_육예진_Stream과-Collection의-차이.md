## Stream과 Collection의 차이

### 정리

**내용 요약**

여러개의 원소를 갖는 원소 시퀀스를 반환하는 메서드에서는 반환타입을 스트림으로 할지 Iterable으로 할지 고민해야 한다.  
스트림 처리 또는 반복 처리 중 해당 메서드를 사용하는 주된 이유에 따라 선택할 수 있지만, 가능하면 컬렉션 타입으로 반환하라.  
Collection 인터페이스는 Iterable의 하위 타입이며, stream 메서드도 제공하여 스트림과 반복을 동시에 지원하기 때문이다.

원소의 개수가 너무 많다면 표준 컬렉션이 아닌 전용 컬렉션을 직접 구현하는 것을 고려한다.   
AbstractCollection을 활용해서 Collection 구현체를 작성할 때는 Iterable용 메서드 외에 contains와 size메서드 구현이 필요하다.  
컬렉션을 반환하는 게 불가능 할 경우에 Stream과 Iterable 중 메서드 셩격에 따라 구현이 더 쉽거나 반환타입에 알맞는 것을 택한다.


### 심화 탐구

**출발점**
 
이번 아이템에 등장한 Stream, Iterable, Collection에 관한 내용들을 이해하기 위해서는 각각의 개념을 알아야 했다.  
따라서 각 인터페이스의 차이에 대해 정리해보려고 한다.  
또, 원소가 많은 시퀀스는 전용 컬렉션을 구현하라는 주장의 근거가 다소 복잡하게 느껴져서 좀 더 간단하게 정리해보았다.


**설명**

<hr>

1. Stream, Interable, Collection

    Stream 인터페이스는 순차적이고 병렬적인 집계 작업을 지원한다.  
    Stream 처리구조에 관한 지난 글(item45)에서 알아보았듯, Stream은 지연처리의 특징을 갖는다.  
    즉, 원소 하나하나에 대한 접근보다는 처리 작업 흐름에 관점을 두고 효율적인 처리를 추구한다.

    Iterable은 반복이 가능한 시퀀스이다.   
    처리하고자 하는 작업이 모두 정의되면 원소를 물흐르듯 한번에 처리하는 스트림의 성격과 달리 원소 각각에 순차적으로 접근할 수 있다.

    Collection은 Iterable 인터페이스를 상속받아 반복이 가능하며, Set, list 등과 같은 구체적인 하위 인터페이스의 구현을 제공한다.  
    stream 메서드를 지원하여 순차 스트림을 반환할 수 있다.

    결국 원소 시퀀스 반환타입으로 Collection이 가장 권장되는 것은 반복과 스트림을 모두 지원한다는 것인데,  
    그 외에도 재사용성이나 원소 접근성에 따른 디버깅 등의 이유로 컬렉션이 더 활용도가 높을 것 같다는 의견이다.

    스트림은 주로 필요한 처리 작업을 줄줄이 정의하고 일회성으로 사용하는 데 비해, 컬렉션은 한번 만들어지면 여러 곳에서 재사용될 수 있다.  
    또, 반복이나 인덱스 등을 통해 각 원소에 대한 접근이 가능하기 때문에 디버깅 면에서 조금 더 유용하지 않을까 싶다.

    그러나, 어느 타입이 더 유용하다고 말하기에 Collection과 Stream은 원소를 다루는 관점이 달라 자료 사용 목적이나 흐름에 따라 적절한 자료형을 반환하는 것이 좋아보인다.  
    다음은 Oracle의 Stream 인터페이스 공식문서의 내용 중 일부이다.

    >컬렉션과 스트림은 표면적으로는 유사하지만 목표는 다릅니다. 컬렉션은 주로 요소의 효율적인 관리와 액세스에 관심이 있습니다. 반면 스트림은 요소에 직접 액세스하거나 조작할 수 있는 수단을 제공하지 않고 대신 소스와 해당 소스에서 집계하여 수행될 계산 작업을 선언적으로 설명하는 데 관심이 있습니다.


2. Java 표준 컬렉션과 전용 컬렉션 구현의 차이

    원소 개수가 많아지면 전용 컬렉션 구현을 고민하라는 것은 왜일까.  
    gpt에 이유를 묻고 타당한 부분을 요약해보았다.  
    [원소 개수에 따라서 표준 컬렉션에 담는 것과 전용 컬렉션을 구현하는 건 어떤 의미가 있어?](https://chatgpt.com/share/c525d72a-9c3c-4a79-b698-c642f0483393)

    표준 컬렉션은 일반적인 사용에 최적화되어 있어서 특정 상황에는 불필요한 메모리 사용이나 성능 저하가 발생할 수 있기 때문이다.

    - 컬렉션들은 특정 원소를 탐색하기 위한 각각의 방식이 존재하는데, 원소 개수가 많아질수록 삽입/조회 등의 성능이 저하될 수 있다.  
    - 컬렉션 크기가 가득 찼을 때 더 큰 공간을 재할당하고 기존의 원소를 복사하는 등의 과정에서 많은 시간이 소요될 수 있다.
    
    이러한 이유로 컬렉션 규모가 커질 때에는 전용 컬렉션 구현을 고려해볼 수 있다.  

    하지만 Java에서 제공하는 컬렉션도 이미 다양한 상황에 맞게 검증되어 있기 때문에 각 표준 컬렉션의 의미와 동작원리를 파악하여 적절히 사용하는 것도 좋은 선택이지 않을까 싶다.  
    전용 컬렉션은 설계 및 구현/테스트 등에 상당한 비용이 들어갈 것이고, 특정 용도에 따르기 때문에 재사용성이 낮으며 문서화를 명확히 하지 않으면 유지보수 또한 어려울 수 있기 때문이다.


<hr>
[참고자료]

- [Stream - Oracle](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)
- [Iterable - Oracle](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)
- [Collection - Oracle](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)
