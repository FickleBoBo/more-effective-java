# hash의 이해 및 hashCode 일반 규약의 존재 이유



## item11 - equals를 재정의하려거든 hashCode도 재정의하라



### 🔍 내용 요약


이전 아이템10에서는 'equals는 일반 규약을 지켜 재정의하라'라는 내용을 학습했다. 
이번 아이템11은 'equals를 재정의하려거든 hashCode도 재정의하라'라는 내용으로 equals를 재정의한 클래스에서 hashCode를 재정의하지 않는다면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제가 될 것을 지적하고 있다. 
그렇다면 hashCode 일반 규약은 무엇이며, 재정의 해야하는 이유는 무엇일까?



Object 명세에서 발췌한 hashCode 일반 규약

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.(단, 애플리케이션을 다시 실행한다면 달라져도 상관없다.)
- equals(Object)가 두 객체가 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equals(Object)가 두 객체가 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.(단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.)


<br>

--------------------------------------------------

### 🧐 심화 탐구

이번 아이템은 전반적으로 생소한 내용이 많아서 이해하기 어려운 점이 많았다. 
특히 hash에 대한 개념이 부족할 뿐만 아니라 hashMap 등의 컬렉션을 잘 사용하지 않아와서 어색함이 많았는데, hashCode를 재정의해야하는 이유를 온전히 이해하기에 앞서 hash는 무엇이며 어떻게 동작하는지를 아는 것이 무엇보다 중요하다고 생각하여 이번 심화 탐구의 주제로 선정하였다. 또한, 이해한 내용을 바탕으로 hashCode의 일반 규약이 필요한 이유를 해석해보고자 했다. 


--------------------------------------------------

### 1. Hash(해시)

hash는 hash function과 동의어로 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수이다. 
이러한 해시 함수를 적용하여 나온 고정된 길이의 값을 해시값이라 한다. 
해시 함수는 보통 입력의 범위보다 출력의 범위가 작으므로 서로 다른 입력값에도 동일한 값이 출력되는 경우도 존재하는데, 이러한 경우를 '충돌'이라고 한다. 

hashMap이나 hashSet은 이러한 해시값을 인덱스로 사용하는 자료구조로, 해시 함수를 이용해 생성한 해시값은 같은 입력 값에 대해 같은 인덱스(해시값)를 리턴하므로 빠르게 원하는 값을 찾을 수 있다.(이상적인 상황에서 O(1)로 찾을 수 있겠다!) 

하지만 위에서 언급한대로 다른 입력값에도 동일한 해시값이 나올 수 있는데, 이때 발생한 충돌을 해결하는 방법은 보통 2가지이다. 

첫번째 방법은 개별 체이닝(Separate Chaining)이란 방법으로, 각각의 인덱스를 연결리스트로 만들어서 같은 해시값이 들어오면 연결리스트에 이어 붙이는 방법이다. 두번째 방법은 오픈 어드레싱(Open Addressing)이란 방법으로, 충돌 발생 시 비어있는 인덱스를 다시 찾아나가는 방법이다. 

두 방법의 특성에 대해 보충하자면 개별 체이닝 방법은 각 인덱스에 연결리스트로 데이터가 이어지므로 데이터를 무한정 저장할 수 있는 반면, 오픈 어드레싱 방법은 전체 인덱스 개수 이상은 저장할 수 없다는 특징이 있다. 자바의 해시 테이블 컬렉션은 개별 체이닝 방식을 사용하고 있다. 

참고자료 : https://namu.wiki/w/%ED%95%B4%EC%8B%9C

--------------------------------------------------

### 2. HashCode()

Object클래스의 메서드로 객체에 대한 해시값(int형)을 반환하는 메서드이다. 
공식 문서에서 일반 규약을 따를 것을 권장하고 있다. 

--------------------------------------------------

### 3. HashTable의 동작 원리

null이 아닌 객체를 key 또는 value로 사용할 수 있는 자료구조로 해시테이블의 크기를 나타내는 capacity, 성능을 위한 기준 지표인 load factor, 각각의 공간을 나타내는 bucket이라는 용어가 있다.(용량 = 버킷 수) 
자바의 경우 해시 충돌에 대해 개별 체이닝 방식을 적용하여 하나의 버킷에 여러 개의 항목을 저장하며 순차적으로 검색한다. 
로드 팩터는 해시 테이블이 자동으로 용량을 증가시키기 전에 얼마나 가득 찰 수 있는지를 나타내는 지표로 저장된 데이터의 개수를 버킷의 개수로 나눈 값이다.(일반적으로 기본 로드 팩터는 0.75)

참고자료 : https://docs.oracle.com/javase/8/docs/api/ 및 ChatGPT 번역 활용

--------------------------------------------------

### 4. equals와 hashCode를 같이 재정의 해야하는 이유에 대한 고찰

제목과 같이 같이 재정의를 해야하는 상황은 일반적으로 hash를 사용하는 컬렉션을 사용할 때 문제가 될 수 있기 때문이다. 
hash를 사용하는 자료구조(HashMap, HashSet, HashTable)은 hashCode()의 리턴 값을 비교하여 다르면 다른 객체로 인식하고 같으면 equals()의 리턴 값을 다시 비교하여 다르면 다른 객체, 같으면 그제야 같은 객체로 인식한다. 이러한 비교 과정 때문에 equals()의 재정의를 통해 다른 객체로 인식될 수 있었던 객체를 같은 객체로 인식하게 바꿔줘도 그 전 단계인 hashCode()에서 다른 객체로 판단해버리면 equals()를 재정의 한게 무의미해지기 때문에 이러한 사태를 방지하고자 같이 재정의할 것을 권장하고 있는 것으로 보인다. 
규약 2이 담고 있는 내용이 이러한 논리 과정을 말하는 것으로 보이며 equals()를 재정의해 같은 객체로 판단하게 했을 경우, hashCode()에서도 같은 객체로 판단하게 하는 것은 필연적으로 보인다. 
규약 3도 비슷하게 equals()에서 다른 객체로 판단하는 것은 hashCode()의 리턴 값과 무관하게 나오게 될 결과로 어떻게 리턴하는 결과는 동일하며, 대신 equals()처럼 다른 객체로 판단하면 equals()에서 한번 더 판단하는 과정을 생략하게 되므로 여기서 성능 향상을 야기할 수 있다고 말하는 것으로 보인다. 

참고자료 : https://tecoble.techcourse.co.kr/post/2020-07-29-equals-and-hashCode/
(사진을 참고해주세요.)

--------------------------------------------------

### 🧠 어려웠던 점 및 생각해볼 점

- hash가 들어가는 컬렉션을 잘 사용하지 않아 어색함이 많았던 아이템이였다. 본문에는 없지만 해시테이블, 해시맵, 해시셋 등에 대해 추가 학습하며 각각의 컬렉션의 차이를 알아보는 것도 많은 도움이 될 것 같다. 
- 해시 함수에 구현에 대한 설명은 생략했는데, 자바에서 기본 제공하는 방법 외에도 몇가지 방법들이 존재하며 가볍게 읽어보기엔 좋을 것 같습니다. 
- 규약 1이 꼭 필요한 이유를 아직 잘 납득하지 못했습니다. 
  1. equals() 비교에 사용되는 정보가 변경되지 않았다면이 equals()를 오버라이드 하지 않았다와 동일한 말인지
  2. 애플리케이션이 다시 실행한다면 이 값이 달라져도 상관없다는게 다시 실행한 상태에서는 같은 값을 계속 반환해야하지만, 다시 실행하기 전이랑 동일할 필요는 없다는 말인지
