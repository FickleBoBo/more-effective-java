# 객체 지향적 관점에서 본 정적 메서드와 정적 필드



## item04 - 인스턴스화를 막으려거든 private 생성자를 사용하라

### 🔍 내용 요약

정적 메서드와 정적 필드만을 담은 클래스의 경우 객체 지향적 관점에서 그리 곱게 보이지는 않지만, 분명 나름의 쓰임새가 있어서 사용되고 있다.

예를 들면, 
- `java.lang.Math`나 `java.util.Arrays`처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓을 수 있다.
- 또는 `java.util.Collections`처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 수도 있다.
- 마지막으로, `final 클래스`와 관련한 메서드들을 모아놓을 때도 사용한다.

이러한 클래스들은 인스턴스로 만들어 쓰려고 설계한 것이 아니기 때문에 인스턴스화 되는 것을 막아야하는데 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다. 추상 클래스로 만드는 것으로는 하위 클래스를 만들어 인스턴스화하면 그만이므로 인스턴스화를 막는 방법은 컴파일러는 명시된 생성자가 없을 때만 기본 생성자를 만드는 점을 이용한 `private 생성자`를 추가하는 방법이다.

<br>

--------------------------------------------------

### 🧐 심화 탐구

알고리즘 문제들을 해결해나가는 과정에서 정적 메서드와 정적 필드는 문제를 해결하는 열쇠가 되는 일이 잦았다. 정적 메서드로 만들어야 main 메서드에서 참조, 호출(referenced)할 수 있으며, 재귀 함수를 설계할 경우 정적 필드를 통해 값을 갱신하며 찾아나가기도 한다. 

이처럼 유용한 점이 많은 정적 메서드와 정적 필드에 대해 필자는 객체 지향적 관점에서 그리 곱게 보이지 않는다는 평가를 하였는데 객체 지향적 관점에서 정적 메서드와 정적 필드가 어떠한 의미를 갖는지 알아보는 것을 심화 탐구 주제로 선정하였다. 이와 관련해 stack overflow에서 'Why are static variables considered evil?' 이라는 질문에 많은 지지를 받았다는 답변을 번역한 블로그 글을 활용했다. 

--------------------------------------------------

객체 지향 프로그래밍(Object-Oriented Programming, OOP)이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다. 

객체 지향적으로 소프트웨어를 설계한다는 말의 의미는 어떤 프로그램의 일부분에 해당하는 작은 부품, 즉 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 하나의 완성된 프로그램을 만드는 프로그래밍 방법론을 뜻한다. 

객체 지향 프로그래밍의 장점
- 객체 지향적 설계를 통해서 프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다.
- 코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현할 수 있다.
- 인간 친화적이고 직관적인 코드를 작성하기에 용이하다.

참고자료 : https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95

--------------------------------------------------

※ 개인적 해석이 포함되어 있습니다.

질문자
1. 클래스 내에서 만번의 함수를 호출하게 된다면, 그 함수를 static으로 만들어서 class.methodCall()의 형태로 사용하는 것이 만개의 인스턴스를 생성해서 메모리를 어지럽히는 것보다 낫지 않을까요?
   - 나도 공감됨(ex Math 클래스)
2. static 변수는 코드의 상호의존성(inter-dependency)을 줄여준다고 생각한다. 
  - 이건 상호의존성의 의미가 모호하게 느껴지기도 하고, 모듈화를 말하는 거라 해도 잘 공감되지는 않음
3. static은 자바뿐만 아니라 Samlltalk나 Scala와 같은 프로그래밍 언어에서도 널리 이용되는데 유독 자바 프로그래밍에서는 개발자들이 static의 사용을 꺼리는 것 같다. 

답변자
1. static 변수의 상태는 코드 여러 부분에서 영향을 받을 수 있고, 이 경우 변화를 추적하기가 어려워진다. 프로그래밍의 규모가 커질수록 모듈화를 제대로 하지 않으면 시스템의 상태를 추론하는 것이 굉장히 어렵다. 
    - 나도 static 변수는 뭔가 본능적으로 값을 변경하지 않을 녀석만 선언하는 경우가 많은거 같다(그럼 상수나 마찬가지긴 하지만)
2. static은 객체 지향의 패러다임과 상반되는데, 각 객체의 데이터들이 캡슐화되어야 한다는 객체지향 프로그래밍 원칙에 위반된다. static은 scope(변수가 유효한 범위)를 고려할 필요가 없는 경우 유용한데, 이는 절차지향적 프로그래밍이며 좋다 나쁘다가 아닌 방향성의 개념이다.
    - 절차지향과 객체지향 프로그래밍을 하는 사람의 마인드셋 문제인거 같다. 절차지향에 대해 잘 모르겠지만 자바에서 메인 함수 최상단에 선언한 변수는 메인 함수 내에서는 어디서든 쓸 수 있고, 그게 static이나 마찬가지 아닌가 뭐 이런 개념인 것 같다
3. static 메서드는 오버라이딩 할 수 없어서 클래스를 확장하는 것이 어렵다. 또한, static 메서드는 interface를 구현하는데 사용될 수 없다.
    - 아직 잘 이해하지 못한 개념으로 method hiding, method overriding, 정적 바인딩, 동적 바인딩, 컴파일 타임, 런타임 등에 대한 이해가 필요한 것 같습니다. 
4. static 변수는 프로그램이 실행되고 있는 내내 살아있기 때문에 static 변수로부터 메모리를 회수할 수 없어서 가상머신이 메모리 부족을 겪게 될 것이다.(garbage collector가 회수x)
    - 싱글턴 패턴이 인스턴스의 생성과 파괴를 제어할 수 없다라고 생각하는 이유와도 이어질 수 있을 것 같습니다.
5. transient나 volatile과 같은 제어자(modifier)의 사용을 고려해보거나, 메서드 인라이닝을 위해 final 메서드를 사용하는 것을 고려하는 방식으로 속도에 대한 이점을 챙겨볼 수 있다. 
    - 처음 보는 제어자라 찾아보니 native, strictfp, synchronized, transient, volatile 이라는 처음보는 제어자들이 존재했다. 
    - 메서드 인라이닝의 경우 함수의 호출을 줄여 시간적 이점을 가져가는 기술로 함수의 실행시간이 매우 짧을 것으로 예상될 경우 괜찮은 방법으로 보이지만 디버깅이 어려울 수 있고, 함수의 의미를 파악하기 어려울 수 있으니 시기적절하게 사용하자
6. 싱글톤 디자인 패턴으로 여러 개의 인스턴스 생성을 피할 수도 있고, 이 경우 스레드 안정성 및 lazy-initailization을 허용하며 객체가 사용될 때마다 제대로 초기화 됨을 보장하고 서브 클래싱 기법 및 리팩토링에 매우 용이하다. static을 사용하다 리팩토링을 할 경우 훨씬 많은 클래스를 수정하게 되는 일이 있어서 static이 코드의 상호의존성을 줄여준다는 것에 동의할 수 없다.
    - 리팩토링을 할 경우 많은 클래스를 수정한다는 말과 3번의 클래스 확장이 어렵다는 말은 서로 상충되는 말 같은데, 어느정도 알듯말듯 잘 이해가 안된다. 

참고자료 : https://unabated.tistory.com/entry/%EC%99%9C-%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-static%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80

참고자료 : https://www.tcpschool.com/cpp/cpp_cppFunction_inlineFunction

--------------------------------------------------

### 🧠 어려웠던 점

- 자료들을 찾아보며 static 변수의 모든 인스턴스가 공유하는 값이라는 특성이 캡슐화에 위반된다고 했는데, 동의하기 어렵다는 생각이 들었다. 
  - 캡슐화의 데이터 보호(data protection)가 이를 포함하는 개념이라는 확신이 안들었다. 
- transient나 volatile 같은 개념 및 쓰레드 등에 대해 처음 알게 되어 이해하기 어려웠다. 
- static 메서드는 오버라이딩이 불가능하고 interface를 구현할 수 없다는 것을 처음 알게되어 관련 자료들을 찾아보았는데 개념 이해가 약간 어려웠다. 
  - method overriding과 method hiding에 대해 찾아보면 좋을 것 같습니다.
