## 객체의 생성 비용에 대해

### 정리

**내용 요약**

같은 상태와 기능을 가진 객체는 같은 객체를 재활용 하는 편이 성능면에서 좋다.  
>생성자 : new 키워드 사용, 매번 새로운 객체 생성  
>정적 팩터리 메서드 : 이미 생성된 인스턴스 반환 가능, 객체 생성도 가능  
  
1. 새로운 객체 생성 드는 비용(메모리, 성능 등)에 비해 일회성이거나 호출 빈도가 높은 경우 객체 생성을 방지하는 방안을 고려해야 한다.  
2. 기본 자료형이 아닌 박싱타입과 혼합하여 코드를 작성한 경우, 오토박싱(연산시 자동으로 타입을 상호변환해주는 기술)으로 인해 의도치 않게 객체가 대량 생성되는 경우도 검토해 볼 필요가 있다.

그러나, 새로운 객체를 생성해야 하는 시점에 기존 객체를 재사용하는 것이, 불필요한 객체가 생성되는 것보다 더 큰 문제를 불러 일으킬 수 있으니 무조건적으로 객체 생성을 제한하는 방향은 옳지 않다.


### 심화 탐구

**출발점**

해당 아이템에서는 기껏 불필요한 객체 생성 방지에 대해 주장하고는, 새로운 객체 생성이 필요한 시기에까지 재활용을 하면 문제가 더 커진다고 말한다.  
'불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 준다'고 마무리해버린다.

그렇다면 꼭 객체 반복 생성을 막아야 하는 시점이 언제일까.  
책에서 몇가지 예시를 들었지만 '생성 비용이 비싼 객체'를 좀 더 명확히 이해해보고자 했다.

**설명**

<hr>

1. 생성 비용이 비싼 객체?
   
   p32, [코드 6-1] 예시를 보면, String 의 matches를 사용한다. 하지만 matches 라는 메서드 이전에 너무 복잡해보이는 매개변수에 시선이 빼앗겨 버린다.  

    ```java
    static boolean isRomanNumeral(String s){
        return s.matches("^(?=.)M*......중략.......$");
    }
    ```
   
   하지만 '생성 비용이 비싼 객체'에 대해 생각해보려면 여기서 두가지에 집중해야 한다.
   1. 새로운 객체를 생성하는 메서드인가.  
     - 해당 예시에 쓰인 matches 메서드 속으로 파고들어가봤다.

        ```java
        // String 클래스의 matches 메서드
        public boolean matches(String regex) {
            return Pattern.matches(regex, this);
        }
        ```
        ```java
        // Pattern 클래스의 matches 메서드
        public static boolean matches(String regex, CharSequence input) {
            Pattern p = Pattern.compile(regex);
            Matcher m = p.matcher(input);
            return m.matches();
        }
        ```
        ```java
        // Pattern 클래스의 compile 메서드
        public static Pattern compile(String regex) {
            return new Pattern(regex, 0);
        }
        ```
        메서드 안에서 호출되는 또 다른 메서드를 타고 들어간 결과이다.  
        matches 메서드가 정확히 어떤 기능을 하는지는 지금 당장 중요하지 않다.  
        결국 complie 메서드에서 Pattern의 인스턴스를 생성하고 있는 것을 확인했다.  
        이미 존재하는 인스턴스를 불러오는 과정이 아니다.

   2. 호출 빈도가 잦은가.
   - 다시 최초의 matches 호출 시점으로 돌아가본다. (가장 위 코드와 동일하다)
        ```java
        static boolean isRomanNumeral(String s){
            return s.matches("^(?=.)M*......중략.......$");
        }
        ```
        matches 메서드를 사용하여 곧바로 return 하고 있다.
        이러한 경우 isRomanNumeral함수를 사용할 때마다 1번의 과정이 반복적으로 이루어질것이다.  
        거기다 return으로 응답이 끝나면 생성 후 사용된 객체는 곧바로 처리된다.
        (자주 힘들게 만들때마다 바로 버릴거라면 효율이 떨어진다는 말이다.)

        따라서 저자는 compile이라는 Pattern 클래스의 정적 팩터리 메서드를 통해 인스턴스를 미리 생성해두고, 생성해 둔 인스턴스를 가져와 위 과정을 똑같이 거쳐 기능을 구현하고 있다.

        ```java
        public class RomanNumeral {

            private static final Pattern ROMAN = 
                Pattern.compile("^(?=.)M*......중략.......$");

            static boolean isRomanNumeral(String s) {

                // 이부분은 1번의 객체 생성 부분부터 거슬러 올라오는 과정과 동일하다.
                return ROMAN.matcher(s).matches();
            }
        }
        ```

        위와 같이 구현할 경우, 메서드가 수없이 호출되어도 새로운 객체 생성 없이 매개변수에 맞추어 해당 기능을 사용할 수 있다.

    추가로 책에서는 이 메서드에 대해 '유한상태머신을 만들기 때문에' 인스턴스 생성비용이 높다고 말한다.  
    유한상태머신이란, 유한개의 상태를 정의해두고 조건에 맞는 이벤트에 따라 해당 상태로 변경되는 방식의 동작을 의미한다.
    
    그러나, 객체 생성 비용 측정 기준으로 일반화 하기에는 적절하지 않다고 생각되어 이번 아이템에서는 상세 조사를 생략했다.

**결론**

객체의 생성비용을 판단하기 위해서 우리는 '호출할 때마다 같은 기능의 새로운 객체를 생성하는가', '호출 빈도 대비 객체 유지 시간이 짧은가'를 먼저 확인하고 고민해야 한다.  

또 특정 메서드를 사용함으로 인해 호출하는 과정에서 새로운 객체가 생성되는지 API를 들여다보는 연습을 해야한다.  
당장 알아볼 수 없는 코드들이 가득하더라도, 새로 객체를 생성하는 메서드인지는 어렵지 않게 확인할 수 있을 것이다.   
어떠한 과정을 거쳐 호출되는지 모르고 메서드를 반복적으로 사용했을 때(불필요한 객체를 무작정 생성했을 때), 이유도 알 수 없이 프로그램 성능이 크게 악화될 수 있다. 

그러나 기존 자원을 안전하게 재활용하려면 새 객체의 생성이 어느 시점에서 이루어져야 하는지 검토하는 작업에 공들여야 할 것이다.

<hr>

[추후 공부해볼 개념]
- 유한 상태 머신


[참고 자료]
- Java 기본 API(JRE System Library)