## 의존 객체 주입을 통한 클래스의 확장성 제고

### 정리

**내용 요약**

클래스가 하나 이상의 자원에 의존하고, 클래스 동작에 있어 해당 자원이 영향을 준다면 확장성을 위해 의존 객체의 주입을 고려해보아야 한다.  
즉, 필요한 자원을 클래스 내부적으로 생성하지 않고, 클래스 인스턴스 생성시 매개변수를 통해 외부에서 넘겨주는 것이다.  
(생성자 또는 setter를 통해 주입할 수 있다. 프로그램의 규모가 커질 경우 이러한 과정을 돕는 Spring 등의 프레임워크를 사용할 수 있지만 반드시 필요한 것은 아니다.)

이는 클래스를 단 한가지 유형으로 사용함에서 끝나지 않고, 다양한 매개변수를 통해 유연성을 더할 수 있다.  


### 심화 탐구

**출발점**

의존 객체 주입의 개념을 보다 일상적인 사례를 들어 직접 설명해보고, 그 필요성과 제약 사항에 대해 생각해본다.

**설명**

<hr>

1. 의존 관계란 무엇인가?  

    A 객체가 작동하기 위해 B자원이 꼭 필요하고, B자원의 형태에 따라 영향을 받는다면 A는 B에 의존한다고 한다.  

    <사례 1>
    ```
    붕어빵을 만들기 위해서는 속이 필요한데 속이 팥이냐 슈크림이냐에 따라 붕어빵 종류와 가격이 달라진다.  
    속이 없는 상태에서는 붕어빵을 팔 수 없다. 이때 붕어빵은 속에 의존한다고 할 수 있다.
    ```

    <사례 2>
    ```
    회사에 직원이 있다.   
    직원은 '일을 한다'라는 역할을 가지고 있는데 어떤 직무를 맡냐에 따라 하는 일이 달라진다.  
    직원에게 개발이라는 직무가 주어진다면 코딩을 하게 될 것이고, 마케팅이라는 직무가 주어진다면 소비자 조사를 하게될 것이다.
    직무가 주어지지 않은 상태에서는 일을 할 수 없다. 이때 직원은 직무에 의존한다고 할 수 있다.
    ```
<br>

2. 의존 객체를 왜 주입해야 하는가? (클래스 내부에 직접 명시하는 것보다 나은 이유)  

    자원을 직접 명시한다는 것은 위 <사례 1>에서 팥 붕어빵만 판다고 선언한 상태이다.  
    >이미 주인이 팥붕어빵으로 상품을 정했기 때문에 다른 맛은 주문할 수 없다.  

    <사례 2>에서는 직원이 한가지 직무만 할 수 있는 경우다. 
    >할 수 있는 일이 하나 뿐이라 다른 부서로 이동할 수 없다.   

    정말 특정한 자원에 대해 맞춤형으로 설정하고 전문적으로 사용할 것이 아니라면, 확장 가능성이 있는 편이 좋다.  
    연결 관계를 느슨하게 하여 자원의 종류를 외부에서 결정하고 주입할 수 있다면 확장성이 제고된다.  
    속의 종류를 고객이 선택해서 고를 수 있고, 직원의 직무를 회사가 결정하고 임명한다면 하나의 객체를 다양하게 사용할 수 있는 것이다.

    간단한 코드예시를 만들어봤다.

    [자원을 클래스 내부에 명시했을 때 - 예시 1]
    ```java
    class FishBread {
        // 필드에서 선언 및 생성
        private static final String inside = "팥";

        // 예시는 기본생성자이지만, 어떠한 방법으로든 인스턴스 생성/호출시 '속'이 이미 '팥'임은 변함없다.
        FishBread() {}

        // 정보를 출력하면 어김없이 "팥붕어빵"이 반환될것이다. 
        public String toString() {
            return inside + "붕어빵";
        }
    }
    ```

    [자원을 주입했을 때 - 예시 2]
    ```java
    class FishBread {
        // 필드에서 자원 선언
        private static final String inside;

        // 생성자에 인수를 통해 자원을 주입한 경우, 매개변수 상태에 따라 자원이 결정된다.
        FishBread(String inside) {
            this.inside = inside;
        }

        // 정보를 출력하면 주입된 자원에 따라 결과가 다르게 나타날 것이다.
        public String toString() {
            return inside + "붕어빵";
        }
    }
    ```

    위 두 코드의 차이점은 단 하나, 필드에 선언된 자원의 종류가 누구에 의해 결정되냐는 것이다.  
    아주 간단한 예시만 보아도 클래스의 확장성이 달라짐을 알 수 있다.

    >[예시 1]에서는 속을 바꾸고 싶다면 FishBread 클래스의 코드를 수정해야 하지만,   
    넣고 싶은 속이 많을 경우 매번 클래스를 찾아와 수정할수는 없다.(프로그램의 규모가 커질 경우, 이것은 큰 문제다.)  
    이때, 속의 종류를 외부에서 작성, 결정, 주입할 수 있다면 FishBread는 안정적으로 그 형태를 유지할 수 있을 것이다.


<br>
3. 주입할 자원의 제한  

    자원을 외부에서 결정할 수 있다고 해서 아무거나 넣을 수 있는 것은 아니다.  
    해당 객체가 받아들일 수 있는 자원의 형태를 최소한의 틀을 정해두어야 한다.  

    ><사례 1> 에서는 붕어빵 속으로 넣을 수 있는 재료만 넣어야지, 만약 넣으려는 것이 '물'이라면 그 형태가 알맞지 않다.

    ><사례 2> 에서는 직무라는 이름에 맞는 것을 할당해야지, '수면'을 직무로 할당하는 것은 알맞지 않다.

    따라서 2번에서의 [예시 2] 코드를 다음과 같이 변경하여 주입될 자원의 형태를 제한할 수 있다.

    [주입되는 자원의 형태 제한]
    ```java
    // Inside라는 인터페이스가 있고, RedBean과 Custard는 이를 구현한 클래스이다.
    Interface Inside {
        public String whatIs();
    }
    class RedBead implements Inside {
        public String whatIs() { return "팥"; }
    }
    class Custard implements Inside {
        public String whatIs() { return "슈크림"; }
    }

    // 반면 Water은 Inside를 구현한 클래스가 아니다.
    class Water {
        public String toString() { return "물"; }
    }

    // 붕어빵 클래스
    class FishBread {
        private static final Inside inside;

        // Inside형태의 객체만 매개변수로 들어올 수 있다.
        FishBread(Inside inside) {
            this.inside = inside;
        }

        // inside 자원이 공통적으로 가지고 있을 whatIs라는 메서드를 통해 toString을 정의할 수도 있다.
        public String toString() {
            return inside.whatIs() + "붕어빵";
        }
    }
    ```

    특정 인터페이스를 구현했거나, 특정 클래스를 상속받은 하위 타입의 객체들만 전달 받을 수 있도록 설정하는 것이다.  

    >Water 클래스는 Inside를 구현하지 않았으므로, whatIs() 메서드가 존재하지 않는다.  
    (설령 존재한다고 하더라도 implements라는 키워드를 사용하지 않았기에 컴파일러는 같은 타입으로 인정하지 않는다.)  

    >따라서 속으로 Water가 들어올 경우 (위 코드에서는 불가능하지만) FishBread의 toString메서드에서 오류가 발생할 것이다.  
    자원 타입에 따른 오류 방지를 위해 클래스 간 상속/구현 관계를 활용해 주입될 자원의 타입을 제한해야 한다.

<hr>

[참고 자료]
- [의존성 주입이란?](https://stackoverflow.com/questions/130794/what-is-dependency-injection)
- [Dependency Injection Benefits(의존성 주입의 이점)](https://jenkov.com/tutorials/dependency-injection/dependency-injection-benefits.html)