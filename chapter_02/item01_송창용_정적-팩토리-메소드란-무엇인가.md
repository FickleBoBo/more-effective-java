## 정적 팩토리 메소드란 무엇인가

### 정리

**내용 요약**

저자는 2장 객체의 생성과 파괴에 들어오며 '객체를 생성해야 할 때', '객체를 생성하지 말아야 할 때', '객체를 생성하는 방법', '객체의 불필요한 생성을 피하는 법'을 알아야한다고 밝혔다.

item1에서는 `정적 팩토리 메소드`를 `생성자`대신 사용하여, 객체를 `생성하지 않고` 불러오는 방법을 소개하고 있다.

`정적 팩토리 메소드`에 대한 장점으로는 다섯 가지가 제시되었다.

+ 정적 팩토리 메소드는 생성자와 달리 `이름을 가질 수 있다.`
    + 이름을 가질 수 있다는 것은 코드 자체로 보았을 때, 생성자보다 추가적인 정보를 바로 보여줄 수 있다는 것이다.
    ```
    BigInteger.probablePrime
    BigInteger(1, 1, 1)
    ```
    + 위의 정적 팩토리 메소드를 보면 아래의 생성자보다 소수를 반환한다는 기능을 더 파악하기 쉽다.

+ 정적 팩토리 메소드는 인스턴스를 `새로 생성하지 않아도 된다.`
    + 객체를 생성하지 않음으로써 객체를 생성할 때 발생하는 생성 비용을 최소화할 수 있게 된다.


+ 정적 팩토리 메소드는 반환타입의 `하위 타입 객체`를 반환할 수 있다.
    + 이러한 특성 때문에 API의 크기를 작게 유지할 수 있고,
    + 따라서, 개발자들이 그 API에 대하여 쉽게 이해하고 접근할 수 있게 된다.


+ 정적 팩토리 메소드는 입력 매개변수(메소드 시그니처)에 따라 `다른 클래스의 객체를 반환할 수 있다.`
    + 이 기능을 이용하면, 정적 팩토리 메소드의 매개변수에 따라서 어떠한 클래스가 호출되는지 프로그래머가 신경쓰지 않아도 된다.
    + 그러므로, 프로그래머가 해당 API에 대한 접근성이 높아지고, 또한 해당 API를 수정하거나 개선할 때도 용이하다.

+ 정적 팩토리 메소드를 `작성하는 시점`에는 `반환할 객체의 클래스가 존재하지 않아도 된다.`
    + 이러한 기능은 `서비스 제공자 프레임워크`의 근간이 된다.

+ 위와 같이 5개의 장점이 존재하지만, 정적 메소드 팩토리에도 단점이 존재한다.
    + 클래스 내부에 정적 팩토리 메소드만 존재하고 public 또는 protected 생성자가 없다면, 하위 클래스를 만들 수 없다.
        + 하지만 불변 타입과 관련하면 이 단점 또한 장점으로 간주할 수 있다.

    + 생성자는 API 설명에 명확하게 드러나지만 정적 팩토리 메소드는 그렇지 않기 때문에, 
    + 개발자가 정적 팩토리 메소드를 찾아내는 것은 상대적으로 더 많은 자원을 소모하게 만든다.

### 심화 탐구

**출발점**

+ 책에서 정적 팩토리 메소드에 대한 예시로 valueOf 메소드를 보여주었지만, Boolean 클래스와 TRUE, FALSE에 대한 지식이 없다보니 정적 팩토리 메소드에 대한 설명이 와닿지 않았다.

+ 정적 팩토리 메소드로 객체를 가져오지 않고 생성자를 통해 인스턴스를 생성할 때 발생하는 '생성 비용'에 대해 이해할 수 없었다.

+ 'API를 만들 때, 구현 클래스를 공개하지 않고도, 그 객체를 반환할 수 있어, API를 작게 유지할 수 있다'는 말이 전혀 이해가 되지 않았다.

+ 정적 팩토리 메소드를 작성하는 시점에는 반환하는 타입의 클래스가 존재하지 않아도 된다는 장점을 서비스 제공자 프레임워크를 통해 설명하였지만, 서비스 제공자 프레임워크에 대한 지식 부족으로 해당 설명을 이해할 수 없었다.



**설명**

#### Boolean 클래스와 TRUE, FALSE에 대해서.

```java
public static Boolean valueOf(boolean){
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

+ 자바에서는 boolean 값을 두 가지 형태로 나타낼 수 있다.
    + 하나는 Boolean 클래스에서 정의된 상수인 TRUE와 FASLE이고,
    + 다른 하나는, boolean 타입의 원시 값인 true와 false이다.

+ Boolean.TRUE 와 true는 똑같이 `참` 값을 나타내지만, 차이가 존재한다.
    + Boolean 클래스는 원시 타입 데이터를 객체로 다루기 위해 사용하는 래퍼 클래스(Wrapper class)의 일종이다.
    + 따라서 Boolean은 매개변수로 객체 타입 데이터를 받는 메소드에서 사용될 수 있다.

    + 원시 타입 데이터인 true는 객체 타입 데이터를 매개변수로 갖는 메소드에서 사용될 수 없는 한계가 있지만,
    + Boolean 클래스보다 메모리 사용이 적다는 장점이 있다.



#### 객체를 생성할 때 발생하는 '생성 비용'

+ Java에서 객체를 생성하면 Heap 영역에 저장된다.

    + 생성된 객체의 경우 직접 제거하기 전까지 Heap 영역에 존재하여 메모리를 소모하게 된다.
    
    + Heap 영역에 존재하는 객체 자체도 프로그램의 성능 저하의 원인이 되지만,
        + Garbage Collector가 작동하여 객체를 제거하는 것 또한 성능 저하의 원인이 된다.

    + 따라서, 객체를 생성하게 되면 이러한 `생성 비용`이 발생하기 때문에, 생성자 대신 `정적 팩토리 메소드`를 사용해 비용을 최소화하는 것이 좋다.


#### 'API를 만들 때, 구현 클래스를 공개하지 않고도, 그 객체를 반환할 수 있어, API를 작게 유지할 수 있다'

정적 팩토리 메소드는 반환 타입의 하위 타입 객체를 반환할 수 있다.
이러한 기능을 통해 API를 작게 유지할 수 있다는 설명이 나왔지만, 개념들을 자세히 알고 있지 못해 설명을 이해할 수 없었다.

우선 API의 개념에 대해서 확실하게 하고 넘어가겠다.

+ `API`란 다른 프로그램에서 사용할 수 있도록 프로그래밍 언어로 구현된 기능들로 구성되어 제어할 수 있도록 하는 `인터페이스`이다.

다음으로 구현 클래스에 대해 알아보겠다.

+ 언급되는 사이트나 책마다 `구현 클래스` 외에도 `구상 클래스`, `구체 클래스`라고도 하는 이 클래스는 `모든 메서드가 완전하게 구현되어 있는 클래스`를 말한다.
    + 쉽게 이해하기 위해서는 더 흔하게 알고 있는 `추상 클래스`와 대비되는 개념이라고 보면 된다.

+ 구현 클래스를 공개하지 않고도 해당 객체를 반환할 수 있기 때문에, API를 작게 유지할 수 있다는 것은 무슨 말일까.
    ```java
    public interface HelloWorld {

        static HelloWorld friend(String name){
            if(name.equals("송창용")){
                return new HelloMyself();
            } else {
                return new HelloRealFriend();
            }
        }

    }
    ```

    + 이러한 코드가 작성되었다고 할 때, HelloWorld의 하위 클래스인 HelloMyself와 HelloRealFriend를 반환할 수 있기 때문에,
    + HelloWorld에서는 각 HelloMyself와 HelloRealFriend라는 구현 클래스 내부의 `완전하게 구현된 메서드`를 굳이 보여주지 않아도 되어,
    + HelloWorld라는 `API의 크기를 작게 유지할 수 있게 되는 것`이다.

#### 정적 팩토리 메소드를 작성하는 시점에는 반환하는 타입의 클래스가 존재하지 않아도 된다.

위에서 예시로 작성한 Java 코드를 다시 한 번 살펴보자.

```java
public interface HelloWorld {

        static HelloWorld friend(String name){
            if(name.equals("송창용")){
                return new HelloMyself();
            } else {
                return new HelloRealFriend();
            }
        }

    }
```

+ 다섯 번째 장점으로 제시된 문장을 이 코드에 적용해보면,
    + HelloWorld를 작성하는 시점에는, HelloMyself와 HelloRealFriend 클래스가 존재하지 않아도 된다는 것이다.
    + `작성하는 시점`에 존재하지 않더라도, 런타임 단계에서 의존성 주입을 통해 반환 타입 클래스를 지정해면 되기 때문에,
    + 런타임 단계 시점에서, HelloMyself와 HelloRealFriend 구현체를 원하는 것으로 변경할 수 있다.

    + 이 장점의 대표적인 예시로는 `서비스 제공자 프레임워크`인 'JDBC'가 있다.
        + `서비스 제공자 프레임워크`란 서비스를 제공하는 측에서 기능을 구현하고 등록하면 그것을 바로 개발자가 사용할 수 있도록 만들어주는 프레임워크를 말한다.
        + JDBC의 개발팀은 사용자의 요구에 맞춰서 지속적으로 기능을 개발하는데,
        + `정적 팩토리 메소드 작성 시점`에는 반환 타입의 클래스가 존재하지 않아도 되는 특성 덕분에
            + 런타임 단계에서 새로 기능이 추가된 클래스를 반환하도록 만드는 것이 용이하다.



**참고**

Boolean.TRUE, Boolean.FALSE 이해하기
https://www.baeldung.com/java-boolean-true-primitive-vs-constant#introduction

API란 무엇인가요
https://aws.amazon.com/ko/what-is/api/

Concrete Class
https://docs.oracle.com/cd/E19205-01/819-3701/con_3268.htm