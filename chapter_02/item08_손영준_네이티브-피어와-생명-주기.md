## 네이티브 피어와 생명 주기

### 정리

**내용 요약**

`finalize`와 `cleaner`의 사용은 지양되어야 한다. 두 객체 소멸자는 예측 불가능성, 비효율성, 불필요성을 고려하면 쓰일 수 없다. 이는 JVM이 이미 가비지 콜렉팅(garbage collecting)을 주관하는 까닭이다. 저자는 특히 "상태를 영구적으로 수정하는 작업"에서는 이러한 소멸자들의 사용을 강력하게 지탄한다.

만약 언제 종료될 지 모르며, 약 50배 정도 (12 ns vs. 550 ns) 느리더라도 객체가 소멸되었다고 가정하자. 객체는 특정한 작업을 수행하던 도중에 예외마저 무시된다. 즉, 프로그래머는 객체는 훼손되어 그 상태를 특정할 수 없다. 이러한 특성은 `finalizer`에 대한 수행을 통한 보안 공격으로 이어질 수도 있다. 이에 `final`이 아닌 클래스를 `finalize` 메서드를 `final`로 선언하는 방식이 제시되기도 한다.

두 문제투성이 소멸자들보다, 종료가 필요한 자원에는 `AutoCloseable` 인터페이스의 구현이 요구된다. `try-with-resource` 방식의 사용과 객체의 유효성 검사도 마찬가지다.

대신 객체 소멸자는 (1) `close` 미호출 시 자원 회수 안전망 (2) 네이티브 피어에서 쓰인다. 물론 안전망으로 쓰일 때에는 순환참조로 인한 메모리 누수에 주의해야 한다. 정적 중첩 클래스가 아닌 중첩 클래스나 람다는 외부 참조를 향하기 쉽다.

추가로, 이번 장의 내용은 [Should Java finalizer really be avoided also for native peer objects lifecycle management?](https://stackoverflow.com/questions/44095247/should-java-finalizer-really-be-avoided-also-for-native-peer-objects-lifecycle-m)에 잘 요약되어 있기도 하다.

### 심화 탐구

**출발점**

해당 절은 종료되어야 하는 자원을 가지고 있는 객체의 소멸에 관해 이야기한다. JDBC를 이용했던 경험에서, `AutoClosable` 인터페이스와 `try-with-resource`에 대한 설명은 충분히 이해되었다. 

그러나 네이티브 피어가 "일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체"라는 것은 무슨 뜻인지 와닿지 않았다. 특히 왜 자바 피어를 회수하면서 네이티브 객체까지 회수하지 못하는지 원리가 명시되지 않았다. 그렇다면 네이티브 객체는 자바 피어 내에서 다른 무언가를 이미 참조하고 있는 객체일텐데, 이 다른 무언가는 무엇일까?

**설명**

1. 네이티브란 어떤 의미인가?

우선, 네이티브 메서드(native method)는 자바 이외의 프로그래밍 언어로 구현되었지만 자바 어플리케이션에서 호출되는 메소드를 말한다. 이러한 정의는 '네이티브(native)'라는 말을 자바가 아닌 다른 언어, 주로 C/C++에 기반한다는 의미로 삼는다. 이는 프로그램 성능을 향상시키고, 플랫폼 의존적 특성을 지원하며, 이미 작성된 코드를 이용할 수 있도록 한다.

동시에 네이티브 피어(native peer)는 자바 피어(java peer)와 함께 살펴보아야 이해할 수 있다. 그 이름에서 드러나듯, 서로가 엮여있는(linked) 관계에서 피어라고 불리는 까닭이다. 앞선 '네이티브'의 의미를 다시 한 번 떠올려보자. 그렇다면 자바 피어는 자바 어플리케이션에서 네이티브 피어의 기능을 호출한다. 이러한 관계를 잘 담은 코드가 있어 가져왔다.

2. 네이티브 피어의 이용과 객체 소멸

- Native Class

```C++
//https://stackoverflow.com/questions/4568972/what-is-a-native-object

class print_hello{
public:
    void do_stuff(){std::cout<<"hello"<<std::endl;}
} 
```

- Java Peer Class

```java
class PrintHello{
    //Address of the native instance (the native object)
    long pointer;

    //ctor. calls native method to create
    //instance of print_hello
    PrintHello(){pointer = newNative();}

    ////////////////////////////
    //This whole class is for the following method
    //which provides access to the functionality 
    //of the native class
    public void doStuff(){do_stuff(pointer);}

    //Calls a jni wrapper for print_hello.do_stuff()
    //has to pass the address of the instance.
    //the native keyword keeps the compiler from 
    //complaining about the missing method body
    private native void do_stuff(long p);

    //
    //Methods for management of native resources.
    //

    //Native instance creation/destruction
    private native long newNative();
    private native deleteNative(long p);

    //Method for manual disposal of native resources
    public void dispose(){deleteNative(pointer);pointer = 0;}
  }
```

위 코드에서 (1) `PrintHello()` 생성자는 `newNative()` 메서드가 네이티브 피어 객체를 생성하도록 만들고, 그 주소를 `pointer`에 저장한다. 

이후 (2) `doStuff()` 메서드를 호출하면 `native` 키워드를 이용하는 `do_stuff(long p)`를 호출한다. 여기에서 `p`는 포인터의 주소다. `native` 키워드는 컴파일러의 접근을 막기에 본문이 비어 발생하는 오류도 발생하지 않도록 한다.

`do_stuff(long p)`가 JNI(Java Native Interface)를 이용하기 위해서는, 아래와 같은 JNI 코드가 선결될 필요가 있다. (원글에서 불완전한 예시 코드임을 밝혔다.)

```java
//the method name is generated by the javah tool
//and is required for jni to identify it.
void JNIEXPORT Java_PrintHello_do_stuff(JNIEnv* e,jobject i, jlong pointer){
    print_hello* printer = (print_hello*)pointer;
    printer->do_stuff();
} 
```

(3) 자바 피어는 네이티브 피어에서 네이티브 메서드인 `do_stuff()` 기능을 이용하기에 `"hello"`가 출력된다.

(4) 마지막으로 `dispose()` 메서드에서 `deleteNative(long p)`를 이용해 포인터의 주소를 0으로 만들어 네이티브 자원을 회수한다.

8장의 내용을 이해하기 위해서는 위 코드의 예시를 다시 살펴볼 필요가 있다. (4)에서 `dispose()`가 프로그래머의 누락에 따라 실행되지 않았다고 가정해보자. C++로 작성된 `print_hello` 클래스 네이티브 피어는 JVM에 할당되어있지 않기에, 가비지 콜렉터가 관리할 수 없다. `deleteNative(long p)`에서도 JNI에 기반해 C++ 코드를 이용하는 이유다.

따라서 "이펙티브 자바" 내에서는 이러한 상황을 방지하기 위해 객체 소멸자 `finalize` (자바 8 이전)와 `cleaner`(자바 9 이후)의 사용을 고려하라고 말하는 셈이다. 물론 여기에도 네이티브 자원 측면과 성능 측면을 무시할 수 없다. 그렇다면 `close` 메서드 혹은 위 코드에서 `dispose()`와 같은 방식을 우선적으로 고려할 필요가 있다.


### Reference

https://wiki.eecs.yorku.ca/course_archive/2017-18/W/4315/_media/lecture13.pdf

https://www.javaworld.com/article/2077520/learn-java/java-tip-23--write-native-methods.html

https://www.baeldung.com/java-native

https://en.wikipedia.org/wiki/Java_Native_Interface

https://stackoverflow.com/questions/44095247/should-java-finalizer-really-be-avoided-also-for-native-peer-objects-lifecycle-m