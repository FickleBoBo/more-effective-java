## 공변과 불공변에 대해

### 정리

**내용 요약**

배열과 제네릭은 대표적으로 두가지 차이점이 있다.
1. 배열은 공변, 제네릭은 불공변이다.
2. 런타임에 배열은 실체화되고, 제네릭은 타입정보가 소거된다.

   - 공변: a가 A의 하위 타입이면, a[]는 A[]의 하위타입이다.
   - 불공변: a가 A의 하위 타입이더라도, List\<a>는 List\<A>와 아무런 관련이 없다.
   - 실체화: 배열은 자신이 담기로 한 원소의 타입을 런타임까지 인지하고 확인한다. 
   - 타입정보 소거(비실체화): 실체화되지 않기 때문에 컴파일 타임에 타입을 체크한다.

런타임에 타입으로 인한 오류가 발생하지 않도록 배열보다는 제네릭을 사용하는 리스트를 권장한다.

### 심화 탐구

**출발점**

이번 아이템은 런타임 시점에 코드 안정성을 제고할 수 있도록 배열보다는 리스트를 사용할 것을 권장하며 그 이유가 되는 사례들이 나열되어 있다.  
전체 흐름으로 봤을때 복잡한 내용을 아니었으나, 공변, 불공변, 실체화, 타입정보 소거 등에 대한 이해 없이는 소화하기 힘들어보였다.

제네릭 사용 이유와 위 키워드 공부를 통해 배열과 리스트에 차이점이 생기는 원리를 이해하는 것이 이번 아이템의 핵심이 아닐까 싶었다.  
따라서 `공변/불공변`, `실체화/비실체화`의 개념과 원리에 대해 탐구해보기로 했다.


**설명**

<hr>

1. 제네릭을 사용하는 이유

    - 컴파일 타임에 타입 검사를 하여 코드의 안정성을 높여준다.
    - 코드에서 형변환 과정을 제거하여 가독성을 향상시킬 수 있다.
   
    >코드의 안정성이란? 
    >의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내 형변환하는 과정에서 발생할 수 있는 에러를 방지한다.


2. 공변과 불공변
   
    >공변: a가 A의 하위 타입이면, a[]는 A[]의 하위타입이다.

    ```java
    // [2-1] 정상 컴파일, 런타임 에러(ArrayStoreException)
    Object[] arr1 = new Long[1];
    arr1[0] = "문자열";

    // [2-2] 컴파일 에러(Type mismatch)
    Long[] arr2 = new Long[1];
    arr2[0] = "문자열";
    ```

    [2-1] Long은 Object의 하위 타입이고, Long[]은 Object[]의 하위타입이기 때문에(공변) `Object[] arr1 = new Long[1];` 해당 부분에서 오류가 나지 않는다.   
    하지만 런타임 시점에 오류를 발생시켜 타입 안전성이 보장되지 않는다.

    [2-2] 추가로, 컴파일 시 배열의 원소 타입은 초기화가 아닌 선언부 타입을 기준으로 검사하는 것으로 보인다.   
    따라서 Object 배열로 선언된 arr1은 문자열이 그 하위타입이기 때문에 정상 컴파일 되고, 런타임에서 에러가 난다.  
    Long 배열로 선언된 arr2는 컴파일에서부터 문자열을 넣을 수 없다.

    - 그렇다면, 타입 안전성이 보장되지 않는 공변의 특성을 왜 배열에 넣었을까? 다형성의 이점을 살리기 위해서다.

        원소의 타입과 상관없는 Arrays클래스의 메서드를 Object 배열의 하위 타입이라면 오버라이딩 없이 어떤 타입의 배열이든 사용할 수 있도록 한것이다.  
        초기에는 그러했으나, 이후 제네릭이 도입되고 와일드카드 등을 통해 다형성을 챙길 수 있게 되면서 배열보다는 리스트를 사용하여 타입 안정성을 보장할 수 있는 코드를 만들도록 권장되고 있다.

    >불공변: a가 A의 하위 타입이더라도, List\<a>는 List\<A>와 아무런 관련이 없다.

    ```java
    // [2-3] 자료를 초기화 하는 부분부터 컴파일 에러 발생(Type mismatch)
    List<Object> test1 = new ArrayList<Long>();

    // [2-4] 정상 코드 예시 - 선언부의 타입매개변수와 초기화부분의 타입매개변수가 일치하거나 초기화 시 타입매개변수 생략
    List<Object> test2 = new ArrayList<Object>();
    ```

    [2-3] 배열과 달리 제네릭을 사용하는 List는 Long이 Object의 하위 타입이더라도 List<Long>과 List<Object>는 서로 다른 컬렉션이다.   
    따라서 해당 코드로는 초기화조차 불가능하기 때문에 런타임에서 타입에 대한 오류를 걱정할 필요가 없다.

    [2-4] 반면 타입매개변수가 같다면 자료형 자체는 하위타입으로 초기화 될 수 있다. (엄연히 말하면 해당 예시에서는 구체화 타입으로 초기화 되어야만 했다.)


3. 어떤 원리로 이런 차이가 생기는 것일까.

    제네릭은 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있도록 컴파일 타임에 타입을 체크하고, 런타임시에는 타입을 소거하는 메커니즘을 가지고 있다.

    때문에 배열은 실체화되지만(런타임까지 원소의 타입을 체크함) 제네릭은 타입이 소거된다(컴파일 타임에 타입 체크하고, 런타임에서는 타입을 알 수 없음).   
    즉 .class 파일에는 제네릭이 존재하지 않는다.

    타입 소거의 예시를 간단한 코드로 살펴보면 다음과 같다.
    ```java
    // 제네릭 타입의 data를 갖는 Node 클래스가 있다.
    // 연결되는 다음 노드의 주소를 가지고 있다.

    // 컴파일 코드
    public class Node<T> {

        private T data;
        private Node<T> next;

        public Node(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }
    }

    // 런타임 코드
    // 제네릭 타입 T가 Object 타입으로 바뀌고, 타입 매개변수 <T>가 모두 삭제됐다.
    public class Node {

        private Object data;
        private Node next;

        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }
    }
    ```
    

**결론**

배열은 공변이고 실체화되므로 컴파일 시점에 타입 오류를 찾지 못할 가능성이 크다.   
리스트는 불공변 특성과 타입소거 매커니즘으로 인해 컴파일 타임에 타입 오류를 발생시키기 때문에 코드 안정성을 보장할 수 있다.

반면, 제네릭 타입 소거에 대해 알게되면서 실제 런타임에 타입에 관한 부분을 확인하지 않는다는 부분은 조금 의심스러웠다.  
아직 소거에 대한 이해가 부족해서 구체적인 예시를 떠올릴 수 없지만, 제네릭 사용 설계에 오류가 있는 경우 문제가 생길 수도 있지 않을까 싶다.

<hr>


[참고 자료]
- [제네릭을 사용하는 이유(oracle)](https://docs.oracle.com/javase/tutorial/java/generics/why.html)
- [타입 소거(oracle)](https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html)
- [제네릭과 공변 불공변 그리고 타입 소거](https://jay-ya.tistory.com/159)