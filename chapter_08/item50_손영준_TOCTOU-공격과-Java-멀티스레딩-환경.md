# TOCTOU 공격과 자바 멀티스레딩 환경

## 정리

자바는 메모리 전체를 하나의 거대한 배열로 다루지 않기에, 메모리 충돌 오류에서 안전하다. 하지만 악의적이든 악의적이지 않든, 외부에서 불변식이 깨지고 클래스가 보호되지 않을 수 있다.

우선, 객체의 허락없이 외부에서 내부를 수정하는 일이 가능하지 않도록 만들어야 한다. `Date` 클래스를 내부 불변 필드로 이용하는 클래스는 `Date` 클래스 자체가 가변이라는 점에서 위험하다. 따라서 `LocalDateTime`이나 `ZonedDateTime`을 이용하는 것이 일반적으로 권장된다.

하지만 이미 작성된 코드들은 어떻게 할 것인가? 블로흐는 방어적 복사(defensive copy)를 통해 인스턴스의 내부를 보호할 필요가 있다고 말한다. 방어적 복사란 생성자에서 받은 매개 변수 그대로가 아니라, 복사본을 만들어 이용하는 방식이다.

또한, 유효성 검사는 복사본 생성 이후에 이루어진다는 점에 주목해야 한다. 특히 멀티스레딩 환경에서는 복사본을 만드는 짧은 순간에 원본 객체가 수정될 수 있는 까닭이다. 이를 두고 검사시점/사용시점 공격(time-of-check/time-of-use, TOCTOU)이라고 한다.

매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본 생성시에 `clone`을 이용해서는 안된다. 만약 불변 클래스가 아니고 확장될 수 있다면, `clone()` 메서드가 악의적 하위 클래스의 인스턴스를 반환하는 경우가 생길 수 있다.

접근자가 가변 필드의 방어적 복사본을 반환하는 방식도 이용할 수 있다. 이는 접근 수준에 대한 우려를 해소시킨다.

즉, 방어적 복사는 클라이언트가 제공한 객체의 변경 가능성을 고려하는 방안이라고 볼 수 있다. 객체가 변경되어도 코드가 잘 돌아가게 되는 경우를 고려해보고, 객체를 믿을 수 없다면 방어적 복사를 진행할 필요가 있다.

하지만 방어적 복사에는 성능 저하 문제가 있고, 접근 정책에서 신뢰된다면 방어적 복사를 생략할 수도 있다. 이는 상호 신뢰할 수 있거나 영향이 호출한 클라이언트로 제한되는 경우에 국한될 것이다.

## 심화 탐구

### 출발점

Java에서의 방어적 복사를 코드 예시와 함께 살펴보려고 했으나, 이미 좋은 레퍼런스가 존재했다. 위 링크에서 방어적 복사에 대해 상세히 살펴볼 수 있으니, 이번 글에서는 검사 시점/사용 시점 공격 (이하 TOCTOU 공격)에서 시작해보고자 한다.

특히, 블로흐의 원글에서도 방어적 복사 필요성을 클라이언트에서 전달받는 객체의 신뢰성 및 내부 수정에의 위험성과 함께 멀티스레딩 환경에서의 TOCTOU 공격을 언급한다. 그렇다면 멀티스레딩 환경에서 TOCTOU 공격을 꼭 방어적 복사본으로 막아야할까?

이번 탐구에서는 TOCTOU 공격에 대해 간단히 알아보고, Java의 멀티스레딩 환경에서는 어떤 방식을 이용할 수 있는지 살펴보겠다.

### 설명

**TOCTOU란**

TOCTOU 공격은 그 이름에서도 알 수 있듯이, 시스템 내에서의 상태 검사와 검사 결과의 이용 사이에서의 경쟁 상태(race condition)에 기반한 공격이다. 경쟁 상태는 시스템에서 입력 순서나 통제 불가능한 사건 발생 탓으로 (특히 공유 자원에서) 예상치 못하거나 비일관적인 결과가 나오는 일을 의미한다. MySQL에서 auto_increment가 분산 환경에서 가질 수 있는 삽입 시 트랜잭션 동시성 문제 역시 race condition의 일종으로 볼 수 있다.

TOCTOU 공격은 파일 권한 검사나 심볼릭 링크, 또는 환경 변수 검사에서 이용될 수 있는데, 실제로도 TOCTOU와 관련된 취약점들이 발견되기도 한다. 대표적인 예시로, 2019년 Aleksa Sarai는 도커에서, 공격자가 심볼릭 링크를 경로에 삽입하여 파일 시스템에 루트 접근이 가능하다는 것을 찾아냈다. 이는 대표적인 TOCTOU 공격이라고 볼 수 있다.

**Java 멀티스레딩 환경에서의 TOCTOU**

TOCTOU 공격을 방지하기 위해서는 경쟁 상태에 대한 대책이 필요하다. 이는 곧 멀티스레딩 환경에서의 스레드 관리와도 연관된다.

1. 떠올리기 쉬운 해결책

쉬운 해결책 중 하나로는, `synchronized` 키워드를 이용하거나 인스턴스 혹은 파일 자체에 락을 적용함으로써 접근 자체을 막을 수 있다. 그러나 위와 같은 방식으로 락을 이용한다면 성능 상의 문제와 함께 교착 상태(deadlock) 발생 가능성을 높이는 탓에 주의가 필요하다.

2. 파일: 부분 잠금

대신, 전체 파일에 락을 걸지 않고 다른 프로세스에서 파일이나 인스턴스 여러 부분을 락을 걸 수 있다. 한 프로세스가 락을 걸고 있는 부분에 대해서는, 다른 프로세스는 락을 걸지 못한다. 이는 최소한의 범위에서만 락이 걸리는 것이다.

여기에서 읽기 잠금은 공유 잠금으로 여러 프로세스나 스레드가 동시에 파일을 읽을 수 있도록 허용하고, 쓰기 잠금은 파일이 변경되는 동안 다른 접근을 방지해 교착 상태를 막는다.

자바에서는 UNIX의 `flock()`과 같이 `FileChannel`과 `FileLock`을 이용해 파일의 일부를 잠글 수 있다. `Filelock` 클래스에서 이용할 수 있는 `lock()` 메서드는 특정 바이트 내의 값을 읽기 잠금 혹은 공유 잠금 처리한다. 이후 `release()` 함수로 락을 해제할 수 있다.

3. 인스턴스: atomic

혹은 `java.util.concurrent.atomic` 패키지 (이하 atomic 패키지)를 이용하면 락을 사용하지 않고도 인스턴스에 대한 경쟁 상태를 막을 수 있다. atomic 패키지는 CAS(Compare-And-Swap) 연산을 이용하는데, 이는 메모리 내 특정 위치에 있는 값을 비교한다. CAS 연산의 원리는 다음과 같다.

(1) 비교: 현재 값이 예상 값과 동일한지 비교
(2) 교환: 현재 값이 예상 값과 동일하면 새로운 값과 교체
(3) 반환: 비교 및 교환 결과 반환

따라서 CAS 연산은 값을 읽고 수정하는 과정을 한 번의 원자적 연산으로 처리해, 중간에 다른 스레드가 값을 변경하지 못하도록 한다.

4. 추가적인 방식

동시성 제어를 통해 경쟁 상태를 해소하는 대표적인 예시는 실제로는 더욱 많다. `ConcurrentHashMap`과 같이 내부가 여러 세그먼트로 나뉘어져 있는 자료구조나, `CopyOnWriteArrayList`와 같이 쓰기 연산이 발생할 때마다 내부 배열이 복사되는 자료구조, `ReentrantReadWriteLock`과 같이 중첩할 수 있는 읽기 잠금과 오직 하나의 쓰기 잠금을 가질 수 있도록 관리하는 락도 있다.

### 나가며

결국, 멀티스레딩 환경에서는 TOCTOU 문제를 막기 위해 원자적 연산이나 동시성 혹은 락에 대해서 고민이 필요한 듯 보인다. 이는 단순히 TOCTOU 문제를 중점에 두기보다는, 사실 멀티 스레딩 환경에서의 메모리 관리나 데이터 정합성을 위해 지금까지 살펴본 여러 요소를 고려할 필요가 있다고 생각한다.

### References

https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use

https://thenewstack.io/how-to-deal-with-race-conditions/?utm_referrer=https%3A%2F%2Fnews.google.com%2F

https://duo.com/decipher/docker-bug-allows-root-access-to-host-file-system

https://www.geeksforgeeks.org/race-condition-vulnerability/

https://docs.oracle.com/javase%2Ftutorial%2F/essential/concurrency/atomicvars.html
