# 열거 타입에서 oridinal 메서드의 효용성



## item35 - ordinal 메서드 대신 인스턴스 필드를 사용하라

### 🔍 내용 요약

대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다. 그리고 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 `ordinal()`이라는 메서드를 제공한다. 
이런 이유로 열거 타입 상수와 연결된 정숫값이 필요하면 `ordinal()` 메서드를 이용하고 싶은 유혹에 빠질 수 있는데 유연한 열거 타입 사용을 위해 `ordinal()` 메서드 대신 인스턴스 필드에 정숫값을 저장하고 사용하자. 

<br>

--------------------------------------------------

### 🧐 심화 탐구

아이템의 분량이 적기도 하고 크게 이해하기 어려운 내용은 아니었던 것 같다. 아이템 마지막에서 필자의 언급처럼 Enum API 문서에서도 `EnumSet`과 `EnumMap` 같이 열거 타입 기반의 범용 자료구조에 쓸 목적으로 설계되었으며 대부분의 프로그래머는 이 메서드를 사용할 일이 없기 때문이다. (Returns the ordinal of this enumeration constant (its position in its enum declaration, where the initial constant is assigned an ordinal of zero). Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap.)

이런 메서드에 대해 프로그래머가 애초에 접근할 수 없게 방지할 수는 없을까 싶었는데, 이에 대해 chatGPT에게 질의응답을 하였는데 일관성과 투명성이라는 Java의 설계 원칙에 의한다는 정도의 답변만 받을 수 있었다. `oridinal()` 매서드가 `public final int oridinal()` 로 되어있는데, 접근제한자를 변경하면 가능하지도 않았을까 싶었다. (반환값은 `oridinal` 인데 `private final int ordinal;` 이다)

`oridinal()` 의 안좋은 사용 예시와 대체 방안은 교재 p.221의 코드가 적절하다고 생각된다. 열거 타입에서 해당 상수가 몇 번재 위치인지를 반환하는 메서드로서 마치 배열의 인덱스처럼 사용할 수 있는데, SQL의 Auto Increment 처럼 0부터 +1씩 증가하는 값으로 매칭이 되기 때문에 중복되는 값을 다룰 수 없고 중간을 비우려고 할 때 비효율이 발생하기 때문이다. 
열거 타입에 정의된 상수의 순서가 바뀌지 않으면서 매칭되는 `oridinal` 값이 의미를 가질 경우 상수 옆에 괄호로 생성자에 넣을 매개변수를 넣어주지 않아도 돼서 가독성 측면에서 소소하게 도움이 될 수 있을지 모르겠다는 생각은 들지만, 공식 문서에서도 직접적인 사용을 지양하는 만큼 다른 방법을 강구하는 것이 좋을 것 같다.(상수와 oridinal 값이 유의미한 관계를 갖을 일이 애초에 잘 없을 것 같고, 있다고 하면 분명 해당 상수를 표현하는 값이므로 인스턴스 필드에 저장하는 것이 맞는 것 같다)



참고 자료 : https://docs.oracle.com/javase/8/docs/api/

--------------------------------------------------

### 🧠 어려웠던 점

이전에 해시에 대해 조사를 하면서 자바에서는 메모리에 대한 프로그래머의 직접적인 접근을 방지하도록 설계된 것으로 보였는데, `oridinal()`에 대해서는 Java 설계 철학에 투명성이 있어서 그렇다는 답변을 받아서 납득하기는 어려웠다. 객체 지향의 캡슐화를 적용할 수 있다면 대부분의 프로그래머에게 단순히 인덱스를 얻을 목적으로 사용하는 것은 지양하지만 `ordinal()`에 대해 충분히 이해한 개발자라면 이를 잘 활용해보라는 의미로 공개해놓은 것인가 하는 생각도 들었다. 
