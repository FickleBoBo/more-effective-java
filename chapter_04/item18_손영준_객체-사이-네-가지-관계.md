## 객체 사이 네 가지 관계

### 정리

상속은 강력하지만, 그만큼이나 제한도 많다. 저자는 특히 캡슐화의 파괴를 상속이 가지는 취약점으로 꼽는다. 이는 상위 클래스의 구현을 변경하면, 하위 클래스에까지 영향이 미치는 까닭이다. 하위 클래스에서 상위 클래스의 필드에 접근할 수 없거나, 상위 클래스에 새로이 정의된 메서드가 하위 클래스에 오류를 일으킬 수도 있다. 상속 관계에서, 상위 클래스의 메서드 재정의나 메서드 추가는 모두 문제를 발생시킬 수 있다.

컴포지션(composition)은 이러한 위험을 피해가도록 돕는다. 컴포지션은 기존 클래스의 확장이 아니라, 새로운 클래스를 만들어 이용한다. 이 새로운 클래스에서, 기존 클래스의 인스턴스는 `private` 필드로 참조된다. 즉, 컴포지션은 기존 클래스를 새로운 클래스의 구성 요소로 이용한다. 이 참조 방식에서 캡슐화는 유지된다.

새 클래스는 기존 클래스에 대응하는 전달 메서드(forwarding method)를 통해서 결과를 반환한다. 이 과정을 전달(forwarding)이라 한다. 전달에서의 대응은 같은 역할을 하는 새로운 메서드를 정의하지 않고, 기존 클래스의 메서드를 통한 결과값을 이용한다는 의미다. 

따라서 컴포지션은 코드 재사용성이 상속보다 높다. 일단 구현체를 완성하면, 기존 생성자는 물론 어떠한 구현체라도 계측할 수 있다. 반면, 상속은 비교적 코드 재사용성이 낮다. 상속은 하위 구현 클래스의 확장과 상위 클래스의 생성자 정의를 각기 요하는 까닭이다.

대신 상속은 하위 클래스가 상위 클래스와 `is-a` 관계를 맺을 때 이용한다. 만약 컴포지션을 이용하며 상속을 쓴다면, 불필요한 `is-a` 관계로 묶인다. 이는 기능적 불편함을 초래할 뿐만아니라, 클라이언트의 직접적인 접근을 허용함으로써 캡슐화를 저해하기도 한다. `Properties`와 `Hashtable`이 맺는 관계가 대표적인 예시다.

### 심화 탐구

**출발점**

이번 절에서는 클래스들 간의 관계가 중점적으로 다루어졌다. `is-a`로 표현되지 않는데 상속이 이용되는 경우에 발생할 수 있는 문제점과 그 대안으로서 컴포지션을 살펴보았다. 이는 상속이 그 효과만큼이나 강력한 제한으로 묶인다는 사실 때문만이 아니라, 컴포지션이 코드 재사용성 등에 대해 갖는 장점 때문이기도 하다.

그런데 이 글에서는 컴포지션이 문제를 해결하는 일종의 도구적 역할을 하는 것처럼 보이기도 한다. 그러나 컴포지션은 객체가 참조하는 방식에 방점이 찍혀야 한다고 생각했다. 따라서 객체 간의 관계를 나타내는 표현 중 하나로 보여 추가적인 탐구를 진행했다.

**설명**

객체 사이에는 관계를 맺는 네 가지 방식이 있다. 각 방식은 종류와 강도에 따라 나뉜다. 바로 상속, 컴포지션, 애그리게이션, 연관이다. 상속에 대해서는 상위 클래스와 하위 클래스가 이미 `is-a` 로 표현됨을 살펴본 바 있다. 그렇다면 다른 세 가지 관계는 어떠한가?

1. 컴포지션(Composition)

- 소유 관계 O, 생명주기 종속 O

컴포지션은 `has-a` 중 하나로, `belongs-to` 관계를 나타낸다. 이는 한 객체가 논리적으로 더 포괄적이란 뜻이며, 다른 객체는 이에 포섭된 채 존재한다. 여기에서 더 큰 객체의 논리적인 하부로 쓰이는 객체는 더 큰 객체의 존재 없이는 존재할 수 없다. 반면, 더 큰 객체는 하부 객체의 존재 없이도 존재할 수 있다. 건물은 방을 포함하고 있지만, 방은 건물 없이 존재할 수 없다.

여기에서 static이 아닌 중첩 클래스를 떠올려 볼 수 있다. 중첩 클래스는 상위 클래스의 존재 없이 존재할 수 없으나, 상위 클래스는 중첩 클래스에 구속받지 않고 존재할 수 있다. 

2. 애그리게이션(Aggregation)

- 소유 관계 O, 생명주기 종속 X

애그리게이션도 컴포지션처럼 `has-a` 관계를 가진다. 하지만 컴포지션이 포함 혹은 소유 관계에 기반한다면, 애그리게이션에서는 두 객체의 생명주기가 독립적으로 진행될 수 있다. 한 객체는 다른 객체의 생명주기에 종속되지 않아도 된다. 한 객체의 생명주기가 종료된다고 해서 다른 객체의 생명주기 역시 종료되지는 않는다. 만약 자바에서라면, static이 아닌 중첩 클래스를 제외하고는 모든 형태가 멤버가 될 수 있다.

3. 연관(Association)

- 소유 관계 X, 생명주기 종속 X

연관은 가장 약한 정도의 관계로, has-a로 나타내어질 수 없다. 이는 어떤 객체도 서로의 멤버가 아님을 의미한다. 대신 객체들은 서로를 알고 있을 뿐이다. 즉, 연관에서는 객체들이 서로를 소유하지도 않고, 각자의 생명주기를 가진다. 따라서 이를 가장 약한 정도로 볼 수 있는 셈이다.

하지만 연관과 애그리게이션은 코드 수준에서 더 차이가 나진 않는다. 연관과 애그리게이션은 논리적 수준에서의 참조 구분이다. 하지만 이 역시 UML 작성 시에 구분될 필요가 있다.

### References

https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition

https://www.baeldung.com/java-composition-aggregation-association
