## 상수 인터페이스를 사용하지 말아야 할 이유에 대해

### 정리

**내용 요약**

인터페이스는 자신의 인스턴스로 무엇을 할 수 있는지 가이드라인을 제공하는 용도로만 사용해야 한다.   
이 지침에 맞지 않는 예로 '상수 인터페이스'가 있다.  
상수 인터페이스란 메서드 없이 static final 필드로만 가득 찬 인터페이스를 말한다.  

주로 정규화된 이름을 사용하지 않기 위해 상수 인터페이스를 구현하지만,
이러한 상수 인터페이스를 지양하는 주요 이유는 다음과 같다.

1. 사용되지 않을 수 있는 읽기 전용 변수로, 이름공간을 오염시킨다.
2. IDE가 없으면 상수의 출처를 찾기 어렵다.
3. 사용자에게 인터페이스 가이드라인을 제공하는 인터페이스의 역할과 상관이 없다. (특정 상수 인터페이스를 구현했음은 사용자에게 중요하지 않다.)
4. 구현체에서 같은 이름의 상수를 다시 초기화할 경우, 인터페이스 목적과 맞지 않게 동작할 수 있다.

단순히 상수를 공개할 목적이라면 몇가지 대안책이 있다.

1. 특정 클래스나 인터페이스와 강하게 연관된 상수는 그 클래스나 인터페이스 자체에 상수를 추가한다.
2. 열거 타입으로 만들어 공개한다.
3. 유틸리티 클래스에 담아 공개한다.


### 심화 탐구

**출발점**

이번 아이템의 내용이 굉장히 짦음에도 불구하고 상수 인터페이스라는 형태를 처음 알게 된 것에 더해, 익숙치 않은 용어들로 설명이 되어 있어서 그 존재 이유부터 이해하기에 어려움이 있었다.

부가적인 심화 탐구보다도 이번 아이템을 설명하는데 사용된 용어들을 알기 쉽게 풀어 설명하고, 더 간단한 예시를 통해 전달하고자 하는 바를 확실히 이해하는데에 집중했다.


**설명**

<hr>

1. 상수 인터페이스란? 왜 사용할까
   
    >상수 인터페이스란 메서드 없이 static final 필드로만 가득 찬 인터페이스를 말한다.

    예를 들어, 아래와 같은 상수 인터페이스가 있다고 가정한다.  
    (*상수란 static final 로 선언되어 변하지 않는 값을 말한다.)
    ```java
    public interface Nums {
        
        static final int ONE = 1;
        static final int TWO = 2;
        static final int THREE = 3;
    }
    ```

    이건 알겠다. 그런데 이렇게 생긴 인터페이스는 과연 왜 사용하는 것일까.
    >이 상수들을 사용하려는 클래스에서는 정규화된 이름(qualified name)을 쓰는 걸 피하고자 그 인터페이스를 구현하곤 한다.

    '정규화된 이름'이란 특정 엘리먼트 이름 앞에 접두사를 붙여 해당 엘리먼트의 소속을 나타내는 문법이다. 용어는 낯설지만 자주 사용하고 있었다.
    ```java
    int INF = Integer.MAX_VALUE;
    // MAX_VALUE라는 엘리먼트는 Integer 클래스에 속해있다.
    ```
    여기서 Integer. 가 '정규화된 이름'으로 MAX_VALUE의 출처를 표시한다.

    상수 인터페이스를 구현하면 이러한 접두사 없이 상수를 사용할 수 있다.
    ```java
    public class Calculation implements Nums {
        
        int sum = ONE + TWO + THREE;
        // 일반적인 경우: int sum = Nums.ONE + Nums.TWO + Nums.THREE;

        int multiple = ONE * TWO * THREE;
        // 일반적인 경우: int multiple = Nums.ONE * Nums.TWO * Nums.THREE;
    }
    ```
    위 예시와 같이 Nums 인터페이스를 구현한 Calculation 클래스에서는 정규화된 이름이 아닌 상수명만으로 사용이 가능하다.

    상수의 이름만 의미가 명확하다면 코드는 훨씬 깔끔해진다.

2. 상수 인터페이스의 문제점 해석
   
   하지만 저자는 상수 인터페이스 사용이 인터페이스를 잘못 사용한 사례라고 말한다.

   1. >사용되지 않을 수 있는 읽기 전용 변수로, 이름공간을 오염시킨다.

        자바에서 이름공간이란, 위에서 이야기한 정규화된 이름과 같은 맥락이다.  
        개체를 식별하고 참조하는 데 사용하는 고유한 식별자다.  

        >이름공간 또는 네임스페이스(영어: namespace)는 개체를 구분할 수 있는 범위를 나타내는 말로 일반적으로 하나의 이름 공간에서는 하나의 이름이 단 하나의 개체만을 가리키게 된다.  
        >일부 프로그래밍 언어들은 이름공간 안에 변수와 함수를 조직한다. (위키피디아)

        일상 예시로 설명하자면 친척끼리 같은 성을 공유하는 것과 비슷하다.  
        이름 공간을 오염시킨다는 말은 무슨 의미일까. 다음과 같이 이해해보았다. 
        
        ![image](https://github.com/Glenn-syj/more-effective-java/assets/156047141/657b6241-a186-4d94-a86a-7896056bf618)

        Nums를 구현한 Calculation 클래스 이름을 적고 . 을 찍으면 해당 클래스를 통해 접근할 수 있는 변수와 메서드들의 목록이 표시된다.
        
        이때, Calculation 클래스에서는 따로 상수를 선언하지 않았지만, Nums 인터페이스를 구현했기 때문에 ONE, TWO, THREE 상수들이 접근 가능 멤버목록에 있게 된다. 

        위 이미지는 간단한 예시이지만 멤버 변수/메서드가 많을수록 또, 그 위로 상속 관계가 많아질수록 해당 목록은 쌓여만 갈 것이다.   
        더 이상 초기 상수 인터페이스의 필드를 사용하지 않게 되더라도 말이다.

    2. >IDE가 없으면 상수의 출처를 찾기 어렵다.

        IDE를 사용하면 해당 상수를 클릭해 출처를 쉽게 찾아갈 수 있다.

        하지만 IDE가 없다면 어떨까?
        위 1번에서 살펴본 바와 같이 직접 구현한 클래스(구현관계가 드러나 있는 클래스)가 아니라 여러 상속관계를 거쳐 정의된 클래스의 경우, 똑같이 해당 상수들을 상수명만으로 사용하고 있겠지만 그 출처를 알 수 없을 것이다.

        ```java
        public class DigitalCalculation extends Calculation{
            int a = ONE;
        }
        ```

        위처럼 Calculation이라는 구현체를 한번만 상속하더라도 코드만 봤을때 ONE이라는 상수가 어디서 왔는지 알 턱이 없다.

    3. >사용자에게 인터페이스 가이드라인을 제공하는 인터페이스의 역할과 상관이 없다.
   
        인터페이스는 본래 구현체의 타입에 대해 정의하고 설명하는 용도이다.  
        하지만, 단지 상수를 공개하는 용도 뿐인 상수인터페이스의 구현은 사용자에게 아무런 의미를 주지 못한다.

    4. >구현체에서 같은 이름의 상수를 초기화할 경우, 인터페이스 목적과 맞지 않게 동작할 수 있다.
   
        상수인터페이스를 구현한 클래스 또는 그 하위클래스에서 같은 이름의 상수를 초기화해 값을 변경해도 컴파일 오류가 나지 않는다.

        ```java
        public class Calculation implements Nums {
            
            static final int ONE = 11;
            static final int TWO = 22;
        }
        ```
        위와 같이 구현체에서 같은 이름으로 상수를 선언하여 다른 값을 할당하더라도 컴파일 시점에는 오류가 나지 않는다.  
        그러나, 이런식으로 값이 덮여진다면 초기 상수인터페이스에서 의도한 바와 다르게 상수가 사용될 수 있다는 것이다. 

3. 상수 인터페이스를 대체할 방법(열거타입, 유틸리티 클래스)

    단순히 특정 의미를 가진 상수들의 모음을 편리하게 사용하도록 하고싶다면 대체할 방법은 있다.

    - 열거타입

        다음은 상수인터페이스였던 Nums를 열거타입으로 간단히 정의하고 호출해본 예시이다.  
        열거타입을 주제로 한 글이 아니기 때문에 보다 상세한 설명은 생략하고 주석으로 대신했다.

        초기 설정이 복잡해 보일 수 있지만, 비슷한 성격의 상수를 모음으로 관리하기에 굉장히 안정적인 자료형이다.  
        ```java
        public enum Nums {
            // 상수명(값)
            ONE(1),
            TWO(2),
            THREE(3);
            
            // 열거한 상수값의 정의 - ONE이면 1, TWO이면 2..이렇게 할당됨
            final private int num;

            // 인스턴스 생성시 값 할당
            private Nums(int num) {
                this.num = num;
            }
            
            // 값 반환
            public int getNum() {
                return num;
            }
        }

        // 사용 예시
        public class Test {
            public static void main(String[] args) {
                
                // 열거형 타입으로 선언 및 초기화, getXX메서드를 통해 값 호출
                Nums a = Nums.ONE;
                System.out.println(a.getNum());	  // 1
            }
        }
        ```
    
    - 유틸리티 클래스

        마찬가지로 Nums를 유틸리티 클래스(Numbers)로도 만들어보았다.
        ```java
        public class Numbers {

            // private 기본생성자로 상속 막기
            private Numbers() {};
            
            // static 키워드로 인스턴스 없이 사용가능
            static final int ONE = 1;
            static final int TWO = 2;
            static final int THREE = 3;
        }

        public class Test {
            public static void main(String[] args) {
                
                int a = Numbers.ONE;
                System.out.println(a);    // 1
            }
        }
        ```
    
    정규화된 이름을 사용하는 것이 번거롭고, 코드를 복잡하게 한다면 import static 을 통해 해당 부분을 생략할 수 있다.   
    (단, 열거타입 Nums와 유틸리티 클래스 Numbers의 상수명이 같아서 두가지를 동시에 import static 할 경우, 어디 소속을 말하는 건지 알 수 없어서 상수명만으로 사용 불가하다.)

    ```java
    // 정적 임포트
    import static Nums.*;

    public class Test {

        // Enum 타입의 값 호출
        int a = ONE.getNum();
    }
    ```

    ```java
    // 정적 임포트
    import static Numbers.*;

    public class Test {

        // 상수명만으로 호출 가능
        int a = ONE;
    }
    ```

**결론**

상수인터페이스의 문제점은 대부분 이를 구현하고 상속하면서 발생하기 때문에, final 키워드를 통해 이를 막으면 되지 않냐는 의견도 있다.  
하지만 API를 여러사람, 여러 곳에서 공유하고 사용하다보면 초기 목적과 맞지 않게 사용되는 일을 막을 수 없다.  

그렇기 때문에 단순히 상수의 공개와 간편한 사용이 필요한 경우라면 대체 방안을 고려하는 것이 좋다.   
인터페이스는 본래 용도대로만 사용되어야 한다.

<hr>


[참고 자료]
- [상수 인터페이스(위키피디아)](https://en.wikipedia.org/wiki/Constant_interface)
- [이름공간(위키피디아)](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A6%84%EA%B3%B5%EA%B0%84)
